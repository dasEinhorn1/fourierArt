<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>

    <div id="container">

    </div>

		<script src="js/three.min.js"></script>
		<script>
      //SCENE SIZE
      const WIDTH = 400;
      const HEIGHT = 300;

      const VIEW_ANGLE = 45;
      const ASPECT = WIDTH / HEIGHT;
      const NEAR = 0.1;
      const FAR = 10000;

      const container = document.querySelector('#container');

      // Create a renderer, camera, and scene
      const renderer = new THREE.WebGLRenderer();
      const camera =
        new THREE.PerspectiveCamera(
          VIEW_ANGLE,
          ASPECT,
          NEAR,
          FAR
        );

      const scene = new THREE.Scene();

      // Add the camera to scene
      scene.add(camera);

      // starting renderer
      renderer.setSize(WIDTH, HEIGHT);

      // Attach renderer to DOM
      container.appendChild(renderer.domElement);

      // My sphere stuff...
      const RADIUS = 50;
      const SEGMENTS = 16;
      const RINGS = 16;
      // create the sphere's material
      const sphereMaterial =
        new THREE.MeshLambertMaterial(
          {
            color: 0xCC0000
          });

      //CREATE A MESH (PRIMITIVE SPHERE)
      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(
          RADIUS,
          SEGMENTS,
          RINGS),
        sphereMaterial);

      // move it
      sphere.position.z = -300;

      // create a point light
      const pointLight =
        new THREE.PointLight(0xFFFFFF);

      // set its position
      pointLight.position.x = 10;
      pointLight.position.y = 50;
      pointLight.position.z = 130;

      // add to the scene
      scene.add(pointLight);

      // Draw!
      renderer.render(scene, camera);
      const X_SPEED = 1;
      var speed = X_SPEED;
      var group = new THREE.Object3D(); //create an empty container
      group.add(sphere);
      scene.add(group)
      function update () {
        sphere.rotateX(Math.PI / 300)
        sphere.rotateY(- Math.PI / 250)
        sphere.rotateZ(Math.PI / 200)
          //sphere.position.x += speed;
        // Draw!
        renderer.render(scene, camera);
        // Schedule the next frame.
        requestAnimationFrame(update);
      }
      // Schedule the first frame.
      requestAnimationFrame(update);
      group.quaternion.copy( camera.quaternion );
		</script>
	</body>
</html>
